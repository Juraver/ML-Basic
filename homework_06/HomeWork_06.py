# Задача 1
#  N хоббитов делят K кусков эльфийского хлеба поровну,
#  не делящийся нацело остаток остается в корзинке у Сэма.
#  Напишите функцию, которая принимает на вход параметры N, K
#  и возвращает два числа:
#  x - cколько кусков эльфиского хлеба достанется каждому хоббиту, и
#  y - сколько кусков остаётся в корзинке.
#
# # если в функции всё верно, то после выполнения этой строчки, не должно выскакивать ошибок
# assert share_bread(N=3, K=14) == (4, 2)

def share_bread(N, K):

    x = K // N
    y = K % N

    return (x, y)

assert share_bread(N = 3, K = 14) == (4, 2)
print('Задача №1')
print('---------')
print(share_bread(3, 14))

# Задача 2
# В копях Мории хоббиты нашли стену, на которой высечены разные натуральные числа.
# Согласно древним сказаниям, это даты сражений. Хоббиты знают,
# что сражения происходили только по високосным годам. Помогите хоббитам определить,
# является ли год с данным числом датой великого сражения. Если это так,
# то верните строку "YOU SHALL PASS", иначе верните "YOU SHALL NOT PASS".
# Напомним, что в соответствии с хоббитским календарем, год является високосным,
# если его номер кратен 4, но не кратен 100, а также если он кратен 400.
def leap_year(year):
    if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
        # print('YOU SHALL PASS')
        text_result = 'YOU SHALL PASS'
    else:
        text_result = 'YOU SHALL NOT PASS'
        # print('YOU SHALL NOT PASS')
    return text_result
print('Задача №2')
print('---------')
print(leap_year(2024))
assert leap_year(5) == 'YOU SHALL NOT PASS'

# Задача 3
# Для могущественного магического ритуала Гендальфу необходимо быстро подсчитывать
# площадь своего амулета, который умеет менять размеры. Известно, что амулет имеет
# форму треугольника и Гендальф знает длину каждой из сторон. Напишите функцию,
# которая считает площадь амулета по трем сторонам.
# Подсказка: используйте формулу Герона
import math
def amulet_area(a, b, c):
    p = (a + b + c)/2
    ps = p * (p - a) * (p - b) * (p - c)
    try:
        s = math.sqrt(ps)
        return s
    except ValueError:
        print("Вы попали в пространство эльфов и комплексных чисел. Минус под корнем! Введите цифры Гендольфа!")

print('Задача №3')
print('---------')
print(f'Площадь амулета = {amulet_area(3, 4, 5)}')
assert amulet_area(3, 4, 5) == 6

# Задача 4
# Хоббиты собираются пешком идти до Мордора и им нужно подсчитать расстояние,
# которое им предстоит пройти. Хоббиты смогли вспомнить сразу несколько метрик
# расстояния: евклидово, манхэттена и косинусное, так что ваша задача - написать
# функцию под каждую из них. Важное условие - используйте только базовые функции
# для решения.
import numpy as np
import random

def cal_euclidean(a, b):
    s = 0
    for i in range(len(a)):
        s += (a[i] - b[i]) ** 2
    distance = s ** (1/2)

    return distance

def cal_manhattan(a, b):
    s = 0
    for i in range(len(a)):
        s += abs(a[i] - b[i])
    distance = s
    return distance

def cal_cosine(a, b):
    s1 = 0
    s2 = 0
    s3 = 0
    for i in range(len(a)):
        s1 += (a[i] * b[i])
        s2 += a[i] ** 2
        s3 += b[i] ** 2
    distance = s1 / ((s2 ** (1/2)) * (s3 ** (1/2)))
    return distance
print('Задача №4')
print('---------')
a = np.random.randint(-10, 10, size=10)
b = np.random.randint(-10, 10, size=10)
print(f'a = {a}')
print(f'b = {b}')
print(f'Расстояние Евклидово = {cal_euclidean(a, b)}')
print(f'Расстояние Манхеттена = {cal_manhattan(a, b)}')
print(f'Расстояние Косинусное = {cal_cosine(a, b)}')


# GIT.
###
